<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ArtifactDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmi:id="-Y9RcQa0I4g1Jel0o_CC8GQ" name="new_artifact,_BKMqcHaLEeK4jM7SNG5wsw" guid="-Y9RcQa0I4g1Jel0o_CC8GQ" changeDate="2013-02-14T10:44:02.903+0100">
  <mainDescription>&lt;h3>&#xD;
    Software System&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    A system made up of software, hardware, and data that provides its primary value by the execution of the software.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The primary product of any software engineering endeavor, a software system can be part of a larger software, hardware&#xD;
    or business solution.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Associations&#xD;
&lt;/h4>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        helps to address : Opportunity Software System helps to address Opportunity.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        fulfills : Requirements Software Systems fulfills Requirements.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h4>&#xD;
    Justification: Why Software System?&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Essence uses the term software system rather than software because software engineering results in more than just a&#xD;
    piece of software. Whilst the value may well come from the software, a working software system depends on the&#xD;
    combination of software, hardware and data to fulfill the requirements.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Progressing the Software System&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    The life-cycle of a software system is hard to define as there can be many releases of a software system. These&#xD;
    releases can be worked on and used in parallel. For example one team can be working on the development of release 3,&#xD;
    whilst another team is making small changes to release 2, and a third team is providing support for those people still&#xD;
    using release 1. If we treat this software system as one entity what state is it in?&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    To keep things simple, Essence treats each major release as a separate software system; one that is built, released,&#xD;
    updated, and eventually retired. A major release encompasses significant changes to the scope, purpose, usage, or&#xD;
    architecture of a software system. It can encompass many minor releases including internal releases produced for&#xD;
    testing purposes, and external releases produced to support incremental delivery or bug fixes. In the example above the&#xD;
    second team would be producing a series of minor releases (2.1, 2.2, 2.3, etc.) of their software system to allow the&#xD;
    delivery of their small changes.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    During its development a software system progresses through several state changes. As shown in Figure 8, they are&#xD;
    architecture selected, demonstrable, usable, ready, operational and retired. These states provide points of stability&#xD;
    on a software systemâ€™s journey from its conception to its eventual retirement indicating (1) when the architecture is&#xD;
    selected,&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;img alt=&quot;&quot; src=&quot;resources/software_system_states.png&quot; width=&quot;600&quot; height=&quot;439&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Figure 12: The states of the Software System&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    (2) when a demonstrable system is produced to prove the architecture and enable testing to start, (3) when the system&#xD;
    is extended and improved so that it becomes usable, (4) when the usable system is enhanced until it is accepted as&#xD;
    ready for deployment, (5) when the system is made available to the stakeholders who use it and made operational, and&#xD;
    finally, (6) when the system itself is retired and its support is withdrawn. These states can be applied to the initial&#xD;
    release of the software system or any subsequent modification or replacement.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    As indicated in Figure 12, the first thing to do for any major software system release is to make sure that there is an&#xD;
    appropriate architecture available; one that complies with any applicable organizational constraints and addresses the&#xD;
    key technical risks facing the new system. Achieving this may require the creation of a brand new architecture, the&#xD;
    modification of an existing architecture, the selection of an existing architecture, or the simple re-use of whatever&#xD;
    is already in place. Regardless of the approach taken, the result is that the system progresses to the architecture&#xD;
    selected state.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Once the architecture had been selected, it must be shown to be fit-for-purpose by building and testing a demonstrable&#xD;
    version of the system. It is not sufficient to just present a set of rolling screen-shots or a stand-alone version of a&#xD;
    multi-user system. The system needs to be truly demonstrable exercising all of the significant characteristics of the&#xD;
    selected architecture. It must also be capable of supporting both functional and non-functional testing.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The demonstrable system is then evolved to become usable by adding more functionality, and fixing defects. Once the&#xD;
    system has achieved the usable state, it has all the qualities desired of an operational system. If it implements a&#xD;
    sufficient amount of the requirements, if it provides sufficient business value, and if there is an appropriate window&#xD;
    of opportunity for its deployment, then it can be considered to be ready for operational use.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Although a useable system has the potential to be an operational system, there are still a few essential steps to be&#xD;
    performed before it is ready. The system has to be accepted for use by the stakeholders, and it has to be prepared for&#xD;
    deployment in the live environment. In this state, the system is typically supplemented with installation guidance and&#xD;
    training materials.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The system is made operational when it is installed for real use within the live environment. It is now available for&#xD;
    use and to generate value and provide benefit to its stakeholders.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Even after the software system has been made operational, development work can still continue. This may be as part of&#xD;
    the plans for the incremental delivery of the system or, as is more common, a response to defects and problems&#xD;
    occurring during the deployment and operation of the system. Support and maintenance continue until the software system&#xD;
    is retired and its support is withdrawn. This may be because 1) the software system has been completely replaced by a&#xD;
    later generation, 2) the software system no longer has any users or, 3) it does not make business sense to continue to&#xD;
    support it.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    During the development of a major release many minor releases are often produced. For example, many teams using an&#xD;
    iterative approach produce a new release during every iteration whilst they keep their software system continuously in&#xD;
    a usable, and therefore potentially shippable, state. It is then the stakeholder representatives who decide whether it&#xD;
    is ready to be made operational. This approach is not always possible, particularly if major architectural changes are&#xD;
    required as these often render the system unusable for a significant period of time.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Understanding the current and desired state of a software system helps everyone understand when a system is ready, what&#xD;
    kinds of changes can be realistically made to the system, and what kinds of work should be left to a later generation&#xD;
    of the software system.&#xD;
&lt;/p></mainDescription>
</org.eclipse.epf.uma:ArtifactDescription>
