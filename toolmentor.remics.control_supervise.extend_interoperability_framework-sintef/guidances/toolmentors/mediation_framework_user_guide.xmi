<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmi:id="-l2KcymlFwMtkERAVxqxmQg" name="new_toolmentor,_vMaaAEUYEeKK_ttnBPx9Rg" guid="-l2KcymlFwMtkERAVxqxmQg" changeDate="2012-12-13T17:17:01.059+0100">
  <mainDescription>&lt;h3>&#xD;
    Mediation Framework: User Guide&#xD;
&lt;/h3>&#xD;
&lt;h4>&#xD;
    Getting Started&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    This section illustrates how to use the main features of the REMICS mediation framework. For testing purpose, a sample&#xD;
    instance of the mediation framework is available in &quot;the cloud&quot;, at the address&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;a&#xD;
        href=&quot;http://54.247.114.191/net.modelbased.mediation.gui-0.0.1-SNAPSHOT/&quot;>http://54.247.114.191/net.modelbased.mediation.gui-0.0.1-SNAPSHOT/&lt;/a>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    One may want to use this address to experiment the following tutorial sections that will help you getting started,&#xD;
    without necessarily installing the mediation framework by yourself.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In the following, we will explain how use the features of the mediation framework depicted on Figure 2-2 in two ways:&#xD;
    by using the web interface or by sending REST requests to services directly. Such requests may easily be sent to any&#xD;
    URL provided in this section by using the Chrome REST console or any other REST testing tool.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In addition, open-source implementation and documentation are available online at &lt;a&#xD;
    href=&quot;http://sintef-9012.github.com/mediation-portal/&quot;>http://sintef-9012.github.com/mediation-portal/&lt;/a>&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Pushing in the model repository&#xD;
&lt;/h4>&#xD;
&lt;h5>&#xD;
    Using the Web-based Graphical Interface&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    As shown Figure 2-3 below, the web interface allows users to push new models into the repository. We can see, on the&#xD;
    left side of this screenshot, a grey panel where the user can specify a unique identifier for his model, a short&#xD;
    description, and provide the related source file. On the right hand side, we can see the list of models currently&#xD;
    stored in the repository.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The two other repositories, namely mappings and comparisons, are available through similar interfaces.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;img alt=&quot;&quot; src=&quot;./resources/mediation_fig_2-3.png&quot; width=&quot;592&quot; height=&quot;392&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Figure 2-3 Accessing the repositories using the web interface&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Using the REST API&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    The model repository is available as a REST service at the following address:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;a&#xD;
        href=&quot;http://54.247.114.191/sensapp/mediation/repositories/models&quot;>http://54.247.114.191/sensapp/mediation/repositories/models&lt;/a>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    In order to push a model in a repository, you merely need to send a JSON request specifying the name of the model, as&#xD;
    well as its content. Models may be provided in two forms: as an XSD schema by embedding directly the XML description in&#xD;
    the JSON document, or as a specific MoF syntax described in appendix. The snippet below illustrates a simple JSON&#xD;
    request that pushes a XSD file into the repository.&#xD;
&lt;/p>&#xD;
&lt;blockquote style=&quot;MARGIN-RIGHT: 0px&quot; dir=&quot;ltr&quot;>&#xD;
    &lt;p class=&quot;codeSample&quot;>&#xD;
        {&lt;br />&#xD;
        &quot;name&quot;: &quot;my-model&quot;,&lt;br />&#xD;
        &quot;content&quot;: &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?>&#xD;
         ...&quot;&lt;br />&#xD;
        }&#xD;
    &lt;/p>&#xD;
&lt;/blockquote>&#xD;
&lt;p>&#xD;
    Your model will then be available at the address:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;a&#xD;
        href=&quot;http://54.247.114.191/sensapp/mediation/repositories/models/my-model&quot;>http://54.247.114.191/sensapp/mediation/repositories/models/my-model&lt;/a>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h4>&#xD;
    Triggering an existing mediation&#xD;
&lt;/h4>&#xD;
&lt;h5>&#xD;
    Using the Web-based Graphical Interface&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    The simplest way to mediate between two data models is to use the graphical user interface. The mediator service has&#xD;
    its own interface, depicted below by Figure 2 4, below.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    On the left side, a form lets the user specify the model between which he wants to mediate, assuming that those models&#xD;
    are available in the model repository. The user may also select the algorithm that he wants to use to detect equivalent&#xD;
    model elements.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    On the right hand side, a table contains the match detected by the mediation framework. The user may validate or&#xD;
    invalidate the suggestions provided by the mediator service using the buttons available in the &quot;Valid?&quot; column. In&#xD;
    Figure 2 4, suggestions have been restricted to the one containing &quot;Author&quot;. Such filtering facilities are critical to&#xD;
    quickly search through large mappings resulting from mediation between large data models.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;img alt=&quot;&quot; src=&quot;./resources/mediation_fig_2-4.png&quot; width=&quot;592&quot; height=&quot;297&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Figure 2-4 Using the Mediator Service to mediate between two data models&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    Using the REST API&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    Mediations are run by the &quot;mediator&quot; service, available at the following URL:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;http://54.247.114.191/sensapp/mediator/&quot;>http://54.247.114.191/sensapp/mediator/&lt;/a>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    As for the model repository, mediations are triggered by sending a JSON message embedded in an HTTP request. Below is a&#xD;
    sample mediation request, where we specify the URL of the two models between which we want to mediate, and the name of&#xD;
    the algorithm that we want to use for this particular mediation.&#xD;
&lt;/p>&#xD;
&lt;blockquote style=&quot;MARGIN-RIGHT: 0px&quot; dir=&quot;ltr&quot;>&#xD;
    &lt;p class=&quot;codeSample&quot;>&#xD;
        {&lt;br />&#xD;
        &quot;source&quot;: &quot;my-first-model&quot;,&lt;br />&#xD;
        &quot;target&quot;: &quot;my-second-model&quot;,&lt;br />&#xD;
        &quot;algorithm&quot;:&quot;xsd-syntactic&quot;&lt;br />&#xD;
        }&#xD;
    &lt;/p>&#xD;
&lt;/blockquote>&#xD;
&lt;p>&#xD;
    We assume here that both models have been previously pushed in the model repository and will be available in here. The&#xD;
    third parameter is the name of the algorithm that we do want to use. The result of this request will be a mapping,&#xD;
    available in the mapping repository, whose URL will be provided as the response of the mediation. For instance, you may&#xD;
    receive something like:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;a&#xD;
        href=&quot;http://54.247.114.191/sensapp/mediation/repositories/mappings/7ba5cfd1-8b43-4292-892a-b32281ef4189&quot;>http://54.247.114.191/sensapp/mediation/repositories/mappings/7ba5cfd1-8b43-4292-892a-b32281ef4189&lt;/a>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    where the UUID &quot;7ba5cfd1-8b43-4292-892a-b32281ef4189&quot; is (in this very case) the identifier of the resulting mapping,&#xD;
    that contains the actual information computed by the mediation.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Creating an ad hoc Mediation Algorithm&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    The mediation portal let you create your own mediation algorithm by combining existing ones as well as various&#xD;
    predefined functions (including string matching, vectors distance, etc.). The framework let you create various types of&#xD;
    algorithms that you will then be able to combine:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Model Processor, process a single model and produces an alternate version of it. Various common processing such as&#xD;
        pruning, relabeling or translating fall in this category. Formally, a model processor is a function π such as&#xD;
        π:Model→Model&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Model Aggregator, which accepts as input a list of models and produces a single one based on specific criterions.&#xD;
        Formally, a mapping aggregator is a function ε, such as ε:2^Model→Model&lt;br />&#xD;
        Model Slicer, which takes a single model as input and slices it into several sub models. Formally a model slicer is&#xD;
        a function σ, such as σ:Model〖→2〗^Model&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Mediation, which basically accepts two models, one mapping, and refine the mapping based on a specific analysis of&#xD;
        the two given models. Formally, a mediation is a function μ such as: μ∶Mapping ×Model ×Model→Mapping&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Mapping Aggregator, which accepts as input a list of mappings and produces a single one using a specific algorithm.&#xD;
        Formally, a mapping aggregator is a function ε, such as ε:2^Mapping→Mapping&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Mapping Slicer, which accepts a single mapping as input, and break it into various sub mappings. Formally, a&#xD;
        mapping slicer is defined as function σ, such as σ:Mapping〖→2〗^Mapping&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    All together, the existing functions provided by the mediation framework enable to describe complex mediation algorithm&#xD;
    in the functional paradigm. The use of the functional paradigm ensure easy parallelisation of complex and resource&#xD;
    consuming algorithms.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    However, as the Scala language used to implement our framework supports both functional and object-oriented&#xD;
    programming, these functions are also classes, and can easily extended using inheritance. The example below illustrates&#xD;
    how to define a simple mediation algorithm, which, given two models, make the best of a the syntactic and random&#xD;
    matching algorithms. We extend the Mediation class (so we also create a new function) and we specify its behaviour by&#xD;
    overriding the &quot;execute&quot; operation.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    To summarize, the creation of your own mediation algorithm requires to:&#xD;
&lt;/p>&#xD;
&lt;ol>&#xD;
    &lt;li>&#xD;
        Create a Scala class that extends some specific classes and traits provided by the mediation framework, depending&#xD;
        on the type of algorithm you want to create.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Register your algorithm in the mediation portal&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Recompile the mediation framework&#xD;
    &lt;/li>&#xD;
&lt;/ol>&#xD;
&lt;p>&#xD;
    Below is an example of such a composite mediation:&#xD;
&lt;/p>&#xD;
&lt;blockquote style=&quot;MARGIN-RIGHT: 0px&quot; dir=&quot;ltr&quot;>&#xD;
    &lt;p class=&quot;codeSample&quot;>&#xD;
        package net.modelbased.mediation.samples&lt;br />&#xD;
        &lt;br />&#xD;
        import net.modelbased.mediation.library.algorithm._&lt;br />&#xD;
        import net.modelbased.mediation.service.repository.mapping.data.Mapping&lt;br />&#xD;
        import net.modelbased.mediation.service.repository.model.data.Model&lt;br />&#xD;
        &lt;br />&#xD;
        class SampleMediation extends Mediation {&lt;br />&#xD;
        &lt;br />&#xD;
        // We import the standard library of mediation algorithms&lt;br />&#xD;
        import net.modelbased.mediation.library.algorithm.Commons._&lt;br />&#xD;
        &lt;br />&#xD;
        /*&lt;br />&#xD;
        * Here, we specify the behaviour of the mediation, by running a syntactic&lt;br />&#xD;
        * match on one side, a semantic match on the other side, and finally merging the&lt;br />&#xD;
        * two results by selecting the most relevant mapping entries.&lt;br />&#xD;
        */&lt;br />&#xD;
        override def execute(in: Mapping, source: Model, target: Model) = {&lt;br />&#xD;
        val m1 = syntacticMatch(in, source, target)&lt;br />&#xD;
        val m2 = randomMatch(in, source, target)&lt;br />&#xD;
        val result = aggregateByMax(Set(m1, m2))&lt;br />&#xD;
        }&lt;br />&#xD;
        }&#xD;
    &lt;/p>&#xD;
&lt;/blockquote>&#xD;
&lt;h4>&#xD;
    Comparing Existing Algorithms&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Comparing the effectiveness of algorithms is critical in developing of real-life mediation algorithms. When building&#xD;
    mediation algorithms, developer often dispose of a few test models, for which they already know what are the expected&#xD;
    mappings that should be detected automatically. Such expected mappings, so called &quot;oracle&quot;, can be placed in the&#xD;
    mapping repository, and the comparator service will automatically calculate metrics including, precision, recall, or&#xD;
    f-measure, reflecting how close a given mapping is to the oracle, and how effective is the algorithm used to generate&#xD;
    the mapping.&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    Using the web-based Graphical Interface&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    The simplest way to leverage the comparator service is also through the web interface, as it permits to directly&#xD;
    visualize the statistics as bar plots. Figure 2-5 below illustrates the comparison of three mappings, with a specific&#xD;
    oracle. Oracle and subject mappings are selected on the left hand side panel, whereas the comparisons results are&#xD;
    displayed on the right side.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;img alt=&quot;&quot; src=&quot;./resources/mediation_fig_2-5.png&quot; width=&quot;592&quot; height=&quot;359&quot; />&lt;br />&#xD;
    &lt;br />&#xD;
    &lt;strong>Figure 2-5 Using the comparator interface to evaluate the effectiveness of various mediation&#xD;
    algorithms&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    Using the REST API&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    In case one needs to evaluate the relevance of a given mediation algorithm on a given case study, one may want to&#xD;
    evaluate the performance (typically metrics such as precision, recall and f-measure). This is possible using the&#xD;
    comparator service, which given two mappings (one being considered as the oracle, or the reference&quot;) will provide you&#xD;
    with the relevant performance hints. The comparator service is available at the following address&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;a href=&quot;http://54.247.114.191/sensapp/comparator&quot;>http://54.247.114.191/sensapp/comparator&lt;/a>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    In order to trigger the comparator service, you need to send a specific JSON message embedded in a POST HTTP request.&#xD;
    The following code snippet illustrates such a JSON body, where we specify the name of the oracle mapping (in the&#xD;
    mapping repository), the name of the mapping to evaluate against the oracle, and the some additional information&#xD;
    regarding this comparison).&#xD;
&lt;/p>&#xD;
&lt;blockquote style=&quot;MARGIN-RIGHT: 0px&quot; dir=&quot;ltr&quot;>&#xD;
    &lt;p class=&quot;codeSample&quot;>&#xD;
        {&lt;br />&#xD;
        &quot;oracle&quot;: &quot;my-oracle&quot;,&lt;br />&#xD;
        &quot;mapping&quot;: &quot;7ba5cfd1-8b43-4292-892a-b32281ef4189&quot;,&lt;br />&#xD;
        &quot;note&quot;: &quot;This is a test of the comparator service&quot;&lt;br />&#xD;
        }&#xD;
    &lt;/p>&#xD;
&lt;/blockquote>&#xD;
&lt;p>&#xD;
    Following such a request, you may access the result of the comparison at the following address. The comparison contains&#xD;
    the various number of false positive, false negative, true positive and true negative&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;a&#xD;
        href=&quot;http://54.247.114.191/sensapp/mediation/repository/comparisons/my-oracle/7ba5cfd1-8b43-4292-892a-b32281ef4189/&quot;>&#xD;
        http://54.247.114.191/sensapp/mediation/repository/comparisons/my-oracle/7ba5cfd1-8b43-4292-892a-b32281ef4189/&lt;/a>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Statistics concerning a specific evaluation, including precision, recall, and f-measure are then also available at a&#xD;
    different URL such as:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;a&#xD;
        href=&quot;http://54.247.114.191/sensapp/mediation/repository/comparisons/my-oracle/7ba5cfd1-8b43-4292-892a-b32281ef4189/stats&quot;>&#xD;
        http://54.247.114.191/sensapp/mediation/repository/comparisons/my-oracle/7ba5cfd1-8b43-4292-892a-b32281ef4189/stats&lt;/a>&#xD;
    &lt;/li>&#xD;
&lt;/ul></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
