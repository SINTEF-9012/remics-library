<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmi:id="-aRxN8TlzkESsebGXjotxFg" name="new_toolmentor,_G9ud0EU_EeKK_ttnBPx9Rg" guid="-aRxN8TlzkESsebGXjotxFg" changeDate="2012-12-13T17:07:23.173+0100">
  <mainDescription>&lt;h3>&#xD;
    Mediation Framework: About&#xD;
&lt;/h3>&#xD;
&lt;h4>&#xD;
    Framework for Data Mediation&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Data interoperability issues are one of the major obstacles towards large scale reuse and migration of large scale&#xD;
    software systems (e.g., components, services). One peculiarity of data interoperability issues is the &quot;semantic&quot; level&#xD;
    that may be difficult to both detect and mitigate: Communicating the price of a product represented as a single number&#xD;
    implies for instance to agree on the related currency, without which calculations would make no sense.&lt;br />&#xD;
    Data interoperability issues have already been extensively researched by several communities including at least, people&#xD;
    working on databases (entity-relationship models), documents (ontologies), and Model-driven Engineering&#xD;
    (object-oriented models). The past decades of efforts revealed that there is indeed no silver bullet that solves data&#xD;
    interoperability issues , in a &quot;press-button&quot; fashion: While artificial intelligence may indeed help automate most of&#xD;
    the process, a human agent remains needed to confirm and/or sort out difficult cases. In real cases such as DOME or DI,&#xD;
    effective solutions result from the selection (or the combination) of relevant existing algorithms, and in the proper&#xD;
    pre-processing of data so as to reduce noise and maximise algorithms' effectiveness.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In this setting, the contribution of the REMICS project is a framework, which helps designers quickly prototype ad hoc&#xD;
    mediation algorithms, by reusing and combining well documented mediation algorithms, pre-processors, converters, etc.&#xD;
    The key contributions of this framework are:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        A repository of existing mediation algorithms, such as synonyms sets semantic matching, similarity flooding, etc.&#xD;
        (Such algorithms are not described in the following, but can easily be found in the related literature.)&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        A repository of models on which the effectiveness of various alternative algorithms might be assessed&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        A Domain Specific Language (DSL) for rapid prototyping and execution of new mediation algorithms&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    It is worth to note that although the resulting mediations are fully executable and operational, they do not intend to&#xD;
    be put in production, especially if they are supposed to be run intensively. In such a case, one should consider&#xD;
    building an optimized version of the resulting prototype, leveraging grid support, pipelining techniques, and other&#xD;
    advanced mechanisms, ensuring the quality of service expected in a production setting.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Approach Overview&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Figure 2-1 below illustrates the main actors and the related uses cases of the REMICS mediation framework. In this&#xD;
    case, we distinguish between two main actors: the Mediation User and the Mediation Designer. The mediation user&#xD;
    expresses mediation needs (as did several of the REMICS partners), and she may also directly try out some of the&#xD;
    predefined mediation algorithms built-in in the framework. When such mediation algorithms need to be tailored to fit&#xD;
    peculiar cases, the mediation designer comes into play and can quickly prototype and experiment with new ad hoc&#xD;
    algorithms, by combining existing bricks provided by the framework thanks to the mediation DSL. In most complex cases,&#xD;
    he might need to add new elementary bricks to the framework (that will be then available for other users as constructs&#xD;
    of the DSL).&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;img alt=&quot;&quot; src=&quot;resources/mediation_fig_2-1.png&quot; width=&quot;487&quot; height=&quot;271&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Figure 2-1 Overview of the approach as a high-level UML 2 use cases diagram&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The main use cases covered by the mediation framework are the following:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Manage Models, is the responsibility of the mediation user. It helps the user in publishing the models between&#xD;
        which he needs to mediate.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Trigger Mediation gives the ability to the mediation user to select an existing mediation algorithm and to run it&#xD;
        on a specific couple of models.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Validate Mappings gives the ability to the mediation user to &quot;double check&quot; the matches identified between models&#xD;
        elements. As there is no algorithm matching model elements with 100 % accuracy, it is critical that the user&#xD;
        confirms and completes the matches that are automatically computed.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Evaluate Mediation Alternatives: let the user compare the result produced by a given mediation algorithm with an&#xD;
        oracle-mapping (that she may have previously provided). This comparison will result in various metrics including&#xD;
        (precision, recall, f-measure, etc.) reflecting the effectiveness of the selected algorithm. Such evaluation are&#xD;
        also useful for the Mediation Designer who may want to evaluate the effectiveness of new algorithms that she pushes&#xD;
        in the framework.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h4>&#xD;
    Architecture&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    The mediation framework is a set of five services, where each service realizes a specific use case. Figure 2-2 below&#xD;
    depicts the overall architecture of the mediation framework, as a UML 2.x component diagram. In this figure, we used&#xD;
    components to depict services and stereotypes to explicit the underlying technologies (e.g., REST, Scala, HTTP).&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Among these five services, three are devoted to storage, and are labelled as repositories consequently. Storing models,&#xD;
    mappings, and evaluations does not only permit to reuse existing data schemas, but also to compare the performance of&#xD;
    various mediation algorithms, on well accepted samples.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The two remaining services, namely the mediator and the comparator, support the common tasks of the Mediation User. The&#xD;
    mediator lets the user select the two models in the repository between which he wants to mediate, and populate the&#xD;
    mapping repository consequently, with the newly found matches between models elements. The comparator service helps the&#xD;
    users comparing to mapping resulting from different algorithms, and provide coverage statistics such as precision,&#xD;
    recall, f-measure, or accuracy (with respect to an &quot;ideal&quot; mapping, so called &quot;oracle&quot; in the following).&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    As other REST services, these mediation services are natively available through HTTP requests containing JSON&#xD;
    documents. In addition, the mediation framework is equipped with a web-based graphical user interface, which eases the&#xD;
    use of the framework and can be used to showcase the mediation portal. This interface supports the main uses cases&#xD;
    depicted by Figure 2-1.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;img alt=&quot;&quot; src=&quot;resources/mediation_fig_2-2.png&quot; width=&quot;581&quot; height=&quot;448&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Figure 2-2 The Service-oriented Architecture of the Mediation Framework&lt;/strong>&#xD;
&lt;/p>&#xD;
From a technical perspective, the mediation framework is implemented on the top of the Sensapp library (developed by SINTEF&#xD;
ICT in the context of the ENVISION EU project). The core services are implemented in the Scala language, and provide a&#xD;
Scala/Java client API. The web interface is implemented in HTML 5 and Javascript, and leverages the JQuery and Twitter&#xD;
boostrap libraries.</mainDescription>
</org.eclipse.epf.uma:ContentDescription>
